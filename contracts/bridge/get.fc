#include "storage.fc";
#include "../common/dic.fc";
#include "../common/stdlib.fc";
#include "../common/utils.fc";
#include "utils.fc";
#include "../gas.fc";
#include "receipt_dic_helper.fc";

(slice) get_bridge_pool_address(slice jetton_address) method_id {
    load_storage();
    (slice jetton_pool_address, _) = storage::bridge_pool_address_dic.dict_get?(KEY_LENGTH, jetton_address);
    return jetton_pool_address;
}

(int) get_is_jetton_support(int target_chain_id, slice jetton_address) method_id {
    load_storage();
    var token_whitelist = storage::jetton_whitelist_dic;
    var key_hash = create_key(target_chain_id, jetton_address);
    (slice whitelist, int is_support) = udict_get?(token_whitelist, DEFAULT_KEY_LENGTH, key_hash);
    return is_support;
}

(int) is_bridge_paused() method_id {
    load_storage();
    return storage::is_pause;
}

(slice) get_target_contract_address(int target_chain_id) method_id {
    load_storage();
    (slice target_contract, _) = storage::target_contract_dic.udict_get?(32, target_chain_id);
    return target_contract;
}

(slice) get_oracle_address() method_id {
    load_storage();
    return storage::oracle_address;
}

(slice) get_owner() method_id {
    load_storage();
    return storage::owner;
}

(slice) get_admin() method_id {
    load_storage();
    return storage::admin;
}

(slice) get_pause_controller() method_id {
    load_storage();
    return storage::pause_controller;
}


(cell) get_upgrade_status() method_id {
    load_storage();
    return storage::temp_upgrade;
}

(int) get_receipt_hash_status(int receipt_hash,int timestamp) method_id {
    load_storage();
    int bucket_key = timestamp / ONEDAY;
    (cell receipt_hash_dic, int found) = udict_get_ref?(storage::receipt_record_dic_bucket, BUCKET_KEY_LENGTH, bucket_key);
    if (found) {
        (slice value, int found) = udict_get?(receipt_hash_dic, DEFAULT_KEY_LENGTH, receipt_hash);
        if (found) {
            return -1;
        } else {
            return 0;
        }
    } else {
            return 0;
    }
}

(int,cell) get_receipt_hash(int timestamp) method_id {
    load_storage();
    int bucket_key = timestamp / ONEDAY;
    (cell receipt_hash_dic, int found) = udict_get_ref?(storage::receipt_record_dic_bucket, BUCKET_KEY_LENGTH, bucket_key);
    if (found) {
        return (found, receipt_hash_dic);
    } else {
        return (found, null());
    }
}

(int,cell) get_receipt_hash_two_days_ago() method_id {
    load_storage();
    int key = now() / ONEDAY;
    int bucket_key = key - 1;
    (cell receipt_hash_dic, int found) = udict_get_ref?(storage::receipt_record_dic_bucket, BUCKET_KEY_LENGTH, bucket_key);
    if (found) {
        return (found, receipt_hash_dic);
    } else {
        return (found, null());
    }
}

(int) is_receipt_hash_exist(int receipt_hash) method_id {
    load_storage();
    return is_receipt_exist(receipt_hash);
}

(int) get_estimate_create_receipt_fee() method_id {
    return calculate_create_receipt_process_fee();
}

(int) get_estimate_lock_fwd_fee() method_id {
    return calculate_transfer_lock_fwd_fee();
}

(int) get_estimate_swap_fee() method_id {
    return calculate_swap_process_fee();
}

(int) get_estimate_create_native_fee() method_id {
    return calculate_create_native_receipt_process_fee();
}

(int) get_estimate_release_transfer_fee() method_id {
    return calculate_release_transfer_fee();
}

(int,int,int) get_estimate_transfer_lock_fwd_fee_split() method_id {
    return calculate_transfer_lock_fwd_fee_split();
}

(int) get_liquidity_account_fee() method_id {
    return forward_init_state_overhead() + calculate_bridge_liquidity_account_min_storage_fee();
}

